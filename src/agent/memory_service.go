package agent

import (
	"encoding/json"
	"os"
	"path/filepath"
	"sync"

	"vantagedata/config"
)

// MemoryType enum
type MemoryType string

const (
	LongTerm   MemoryType = "long_term"   // Persistent facts: schemas, business rules, data characteristics
	MediumTerm MemoryType = "medium_term" // Compressed conversation summaries (LLM-generated)
	ShortTerm  MemoryType = "short_term"  // Current conversation context (managed by MemoryManager, not persisted here)
)

// SessionMemory holds memory specific to a chat session
// LongTerm: Persistent facts about data sources, business rules, user preferences
// MediumTerm: Compressed summaries of past conversation segments (generated by LLM)
type SessionMemory struct {
	LongTerm   []string `json:"long_term"`   // Data source schemas, business rules, data characteristics
	MediumTerm []string `json:"medium_term"` // LLM-compressed summaries of older conversations
}

// GlobalMemory holds cross-session persistent knowledge
// Only stores truly global facts (e.g., data source descriptions, overall goals)
type GlobalMemory struct {
	DataSources []string `json:"data_sources"` // Data source descriptions and schemas
	Goals       []string `json:"goals"`        // Overall analysis goals and objectives
}

// MemoryService manages agent memory
type MemoryService struct {
	dataDir    string
	globalPath string
	globalMem  GlobalMemory
	mu         sync.Mutex
}

// NewMemoryService creates a new memory service
func NewMemoryService(cfg config.Config) *MemoryService {
	// Use DataCacheDir for storage
	dir := cfg.DataCacheDir
	if dir == "" {
		home, _ := os.UserHomeDir()
		dir = filepath.Join(home, "VantageData")
	}
	
	sessionsDir := filepath.Join(dir, "sessions")
	_ = os.MkdirAll(sessionsDir, 0755)

	path := filepath.Join(dir, "agent_memory.json") // Keep legacy name for global or migrate? Let's use it for global.
	
	service := &MemoryService{
		dataDir:    dir,
		globalPath: path,
		globalMem: GlobalMemory{
			DataSources: []string{},
			Goals:       []string{},
		},
	}
	
	service.loadGlobal()
	return service
}

func (s *MemoryService) loadGlobal() {
	s.mu.Lock()
	defer s.mu.Unlock()

	data, err := os.ReadFile(s.globalPath)
	if err != nil {
		return // File might not exist yet
	}

	// First check if this is old format (has "global" field)
	var rawMap map[string]interface{}
	if err := json.Unmarshal(data, &rawMap); err == nil {
		if _, hasGlobal := rawMap["global"]; hasGlobal {
			// Old format detected, migrate
			var oldMem struct {
				Global []string `json:"global"`
			}
			if err2 := json.Unmarshal(data, &oldMem); err2 == nil {
				s.globalMem.DataSources = oldMem.Global
				s.globalMem.Goals = []string{}
				return
			}
		}
	}

	// Try unmarshal into new GlobalMemory format
	json.Unmarshal(data, &s.globalMem)
}

func (s *MemoryService) saveGlobal() error {
	s.mu.Lock()
	defer s.mu.Unlock()

	data, err := json.MarshalIndent(s.globalMem, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(s.globalPath, data, 0644)
}

func (s *MemoryService) getSessionPath(threadID string) string {
	return filepath.Join(s.dataDir, "sessions", threadID, "memory.json")
}

func (s *MemoryService) loadSession(threadID string) (SessionMemory, error) {
	path := s.getSessionPath(threadID)
	mem := SessionMemory{
		LongTerm:   []string{},
		MediumTerm: []string{},
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return mem, nil
		}
		return mem, err
	}

	err = json.Unmarshal(data, &mem)
	return mem, err
}

func (s *MemoryService) saveSession(threadID string, mem SessionMemory) error {
	path := s.getSessionPath(threadID)
	
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data, err := json.MarshalIndent(mem, "", "  ")
	if err != nil {
		return err
	}

	return os.WriteFile(path, data, 0644)
}

// AddGlobalDataSource adds a data source description to global memory
func (s *MemoryService) AddGlobalDataSource(description string) error {
	s.mu.Lock()
	s.globalMem.DataSources = append(s.globalMem.DataSources, description)
	s.mu.Unlock()
	return s.saveGlobal()
}

// AddGlobalGoal adds an overall goal to global memory
func (s *MemoryService) AddGlobalGoal(goal string) error {
	s.mu.Lock()
	s.globalMem.Goals = append(s.globalMem.Goals, goal)
	s.mu.Unlock()
	return s.saveGlobal()
}

// AddSessionLongTermMemory adds a persistent fact to a session's long term memory
// Use for: data source schemas, business rules, data characteristics
func (s *MemoryService) AddSessionLongTermMemory(threadID string, fact string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	mem, err := s.loadSession(threadID)
	if err != nil {
		return err
	}

	// Avoid duplicates
	for _, existing := range mem.LongTerm {
		if existing == fact {
			return nil // Already exists
		}
	}

	mem.LongTerm = append(mem.LongTerm, fact)
	return s.saveSession(threadID, mem)
}

// AddSessionMediumTermMemory adds a compressed summary to a session's medium term memory
// Use for: LLM-generated summaries of past conversation segments
func (s *MemoryService) AddSessionMediumTermMemory(threadID string, summary string) error {
	s.mu.Lock()
	defer s.mu.Unlock()

	mem, err := s.loadSession(threadID)
	if err != nil {
		return err
	}

	mem.MediumTerm = append(mem.MediumTerm, summary)
	return s.saveSession(threadID, mem)
}

// GetMemories returns all memory context for a specific thread
// Returns: globalDataSources, globalGoals, sessionLong, sessionMedium
func (s *MemoryService) GetMemories(threadID string) (globalDataSources []string, globalGoals []string, sessionLong []string, sessionMedium []string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	// Return copies of global memory
	globalDataSources = make([]string, len(s.globalMem.DataSources))
	copy(globalDataSources, s.globalMem.DataSources)
	
	globalGoals = make([]string, len(s.globalMem.Goals))
	copy(globalGoals, s.globalMem.Goals)
	
	// Load session memory
	mem, _ := s.loadSession(threadID)
	
	sessionLong = mem.LongTerm
	sessionMedium = mem.MediumTerm
	
	return
}

