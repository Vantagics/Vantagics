package agent

import (
	"regexp"
	"strings"
)

// ImagePattern represents a detected image pattern with its type and data
type ImagePattern struct {
	Type string // "base64", "markdown", "file_reference"
	Data string // The extracted image data
	Raw  string // The original matched string
}

// ImageDetector provides utilities for detecting and validating image patterns
type ImageDetector struct {
	// Regex patterns for different image formats
	base64Pattern        *regexp.Regexp
	markdownPattern      *regexp.Regexp
	fileReferencePattern *regexp.Regexp
	sandboxPattern       *regexp.Regexp // Pattern for sandbox: paths (OpenAI code interpreter format)
}

// NewImageDetector creates a new ImageDetector with compiled regex patterns
func NewImageDetector() *ImageDetector {
	return &ImageDetector{
		// Pattern for base64 images: data:image/[type];base64,[data]
		// Matches: data:image/png;base64,iVBORw0KGgo...
		// Matches: data:image/jpeg;base64,/9j/4AAQSkZJRg...
		// Matches: data:image/gif;base64,R0lGODlh...
		// Matches: data:image/webp;base64,...
		base64Pattern: regexp.MustCompile(
			`data:image/([a-zA-Z0-9+\-\.]+);base64,([A-Za-z0-9+/=]+)`,
		),

		// Pattern for markdown images: ![alt](path)
		// Matches: ![alt text](image.png)
		// Matches: ![](path/to/image.jpg)
		// Matches: ![description](https://example.com/image.png)
		markdownPattern: regexp.MustCompile(
			`!\[([^\]]*)\]\(([^\)]+)\)`,
		),

		// Pattern for file references: files/[filename]
		// Matches: files/chart.png
		// Matches: files/output_123.jpg
		// Matches: file://path/to/image.png
		fileReferencePattern: regexp.MustCompile(
			`(?:files/|file://)([^\s\)]+\.(png|jpg|jpeg|gif|webp|svg|bmp))`,
		),

		// Pattern for sandbox paths (OpenAI code interpreter format)
		// Matches: sandbox:/mnt/data/chart.png
		// Matches: sandbox:/mnt/data/output.jpg
		sandboxPattern: regexp.MustCompile(
			`sandbox:(/[^\s\)]+\.(png|jpg|jpeg|gif|webp|svg|bmp))`,
		),
	}
}

// DetectBase64Images finds all base64 image patterns in the given text
// Returns a slice of ImagePattern structs with Type="base64"
func (id *ImageDetector) DetectBase64Images(text string) []ImagePattern {
	var patterns []ImagePattern
	matches := id.base64Pattern.FindAllStringSubmatch(text, -1)

	for _, match := range matches {
		if len(match) >= 3 {
			// match[0] is the full match
			// match[1] is the image type (png, jpeg, etc.)
			// match[2] is the base64 data
			patterns = append(patterns, ImagePattern{
				Type: "base64",
				Data: match[0], // Store the full data URL
				Raw:  match[0],
			})
		}
	}

	return patterns
}

// DetectMarkdownImages finds all markdown image patterns in the given text
// Returns a slice of ImagePattern structs with Type="markdown"
func (id *ImageDetector) DetectMarkdownImages(text string) []ImagePattern {
	var patterns []ImagePattern
	matches := id.markdownPattern.FindAllStringSubmatch(text, -1)

	for _, match := range matches {
		if len(match) >= 3 {
			// match[0] is the full match: ![alt](path)
			// match[1] is the alt text
			// match[2] is the image path
			patterns = append(patterns, ImagePattern{
				Type: "markdown",
				Data: match[2], // Store the path
				Raw:  match[0],
			})
		}
	}

	return patterns
}

// DetectFileReferences finds all file reference patterns in the given text
// Returns a slice of ImagePattern structs with Type="file_reference"
func (id *ImageDetector) DetectFileReferences(text string) []ImagePattern {
	var patterns []ImagePattern
	matches := id.fileReferencePattern.FindAllStringSubmatch(text, -1)

	for _, match := range matches {
		if len(match) >= 2 {
			// match[0] is the full match: files/filename or file:///path
			// match[1] is the filename
			patterns = append(patterns, ImagePattern{
				Type: "file_reference",
				Data: match[1], // Store just the filename
				Raw:  match[0],
			})
		}
	}

	return patterns
}

// DetectSandboxPaths finds all sandbox: path patterns in the given text
// These are generated by OpenAI code interpreter and need to be converted
// Returns a slice of ImagePattern structs with Type="sandbox"
func (id *ImageDetector) DetectSandboxPaths(text string) []ImagePattern {
	var patterns []ImagePattern
	matches := id.sandboxPattern.FindAllStringSubmatch(text, -1)

	for _, match := range matches {
		if len(match) >= 2 {
			// match[0] is the full match: sandbox:/mnt/data/filename.png
			// match[1] is the path: /mnt/data/filename.png
			// Extract just the filename from the path
			path := match[1]
			parts := strings.Split(path, "/")
			filename := parts[len(parts)-1]
			
			patterns = append(patterns, ImagePattern{
				Type: "sandbox",
				Data: filename, // Store just the filename
				Raw:  match[0],
			})
		}
	}

	return patterns
}

// DetectAllImages finds all image patterns in the given text
// Returns a slice of all detected ImagePattern structs
func (id *ImageDetector) DetectAllImages(text string) []ImagePattern {
	var allPatterns []ImagePattern

	// Detect base64 images
	allPatterns = append(allPatterns, id.DetectBase64Images(text)...)

	// Detect markdown images
	allPatterns = append(allPatterns, id.DetectMarkdownImages(text)...)

	// Detect file references
	allPatterns = append(allPatterns, id.DetectFileReferences(text)...)

	// Detect sandbox paths (OpenAI code interpreter format)
	allPatterns = append(allPatterns, id.DetectSandboxPaths(text)...)

	return allPatterns
}

// IsValidBase64Image validates if a string is a valid base64 image data URL
func (id *ImageDetector) IsValidBase64Image(data string) bool {
	if !strings.HasPrefix(data, "data:image/") {
		return false
	}

	if !strings.Contains(data, ";base64,") {
		return false
	}

	// Extract the base64 part
	parts := strings.Split(data, ";base64,")
	if len(parts) != 2 {
		return false
	}

	base64Data := parts[1]

	// Validate base64 format (should only contain valid base64 characters)
	// Base64 uses A-Z, a-z, 0-9, +, /, and = for padding
	validBase64 := regexp.MustCompile(`^[A-Za-z0-9+/]*={0,2}$`)
	if !validBase64.MatchString(base64Data) {
		return false
	}

	// Check that length is valid for base64 (should be multiple of 4 with padding)
	if len(base64Data)%4 != 0 {
		return false
	}

	return true
}

// IsValidMarkdownImage validates if a string is a valid markdown image reference
func (id *ImageDetector) IsValidMarkdownImage(data string) bool {
	// Check if it matches the markdown pattern
	return id.markdownPattern.MatchString(data)
}

// IsValidFileReference validates if a string is a valid file reference
func (id *ImageDetector) IsValidFileReference(data string) bool {
	// Check if it matches the file reference pattern
	return id.fileReferencePattern.MatchString(data)
}

// ExtractImageType extracts the MIME type from a base64 image data URL
// Returns the MIME type (e.g., "image/png") or empty string if not found
func (id *ImageDetector) ExtractImageType(base64Data string) string {
	if !strings.HasPrefix(base64Data, "data:") {
		return ""
	}

	// Extract the part between "data:" and ";base64"
	parts := strings.Split(base64Data, ";base64,")
	if len(parts) != 2 {
		return ""
	}

	mimeType := strings.TrimPrefix(parts[0], "data:")
	return mimeType
}

// ExtractBase64Data extracts just the base64 string from a data URL
// Returns the base64 string without the "data:image/...;base64," prefix
func (id *ImageDetector) ExtractBase64Data(base64DataURL string) string {
	if !strings.Contains(base64DataURL, ";base64,") {
		return ""
	}

	parts := strings.Split(base64DataURL, ";base64,")
	if len(parts) != 2 {
		return ""
	}

	return parts[1]
}

// NormalizeImagePath normalizes a file path to a consistent format
// Handles "files/filename", "file:///path/to/filename", and "sandbox:/mnt/data/filename" formats
func (id *ImageDetector) NormalizeImagePath(path string) string {
	// Remove sandbox: prefix if present (OpenAI code interpreter format)
	if strings.HasPrefix(path, "sandbox:") {
		path = strings.TrimPrefix(path, "sandbox:")
	}

	// Remove file:// prefix if present
	if strings.HasPrefix(path, "file://") {
		path = strings.TrimPrefix(path, "file://")
	}

	// Remove leading slashes
	path = strings.TrimLeft(path, "/")

	// Return just the filename if it's a path
	if strings.Contains(path, "/") {
		parts := strings.Split(path, "/")
		return parts[len(parts)-1]
	}

	return path
}

// CountImages returns the total number of images detected in the text
func (id *ImageDetector) CountImages(text string) int {
	return len(id.DetectAllImages(text))
}

// HasImages returns true if any images are detected in the text
func (id *ImageDetector) HasImages(text string) bool {
	return id.CountImages(text) > 0
}
